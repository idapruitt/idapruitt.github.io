<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Image Viewer</title>
<style>
  html, body {
    margin: 0; padding: 0; height: 100%; background: black; overflow: hidden;
    font-family: sans-serif;
    color: white;
  }
  .container {
    height: 100%;
    display: flex;
    flex-direction: column;
  }
  .thumbnails {
    display: flex;
    justify-content: center;
    gap: 10px;
    background: black;
    padding: 10px;
    z-index: 10;
  }
  .thumbnails img {
    width: 100px;
    height: 70px;
    object-fit: cover;
    cursor: pointer;
    border: 2px solid transparent;
  }
  .viewer {
    flex: 1;
    position: relative;
    background: black;
    overflow: hidden;
    cursor: zoom-in;
  }
  .viewer.zoomed {
    cursor: grab;
  }
  .viewer.zoomed:active {
    cursor: grabbing;
  }
  .viewer img {
    position: absolute;
    top: 50%;
    left: 50%;
    transform-origin: center center;
    max-width: none;
    max-height: none;
    user-select: none;
    pointer-events: none;
    transition: opacity 0.4s ease;
    opacity: 0;
    transform: translate(-50%, -50%) scale(1);
  }
  .viewer img.visible {
    opacity: 1;
    pointer-events: auto;
  }
</style>
</head>
<body>
<div class="container">
  <div class="thumbnails" id="thumbnails">
    <img src="images/thumbnail1.jpg" data-full="images/photo1.jpg" alt="1" />
    <img src="images/thumbnail2.jpg" data-full="images/photo2.jpg" alt="2" />
    <img src="images/thumbnail3.jpg" data-full="images/photo3.jpg" alt="3" />
    <img src="images/thumbnail4.jpg" data-full="images/photo4.jpg" alt="4" />
    <img src="images/thumbnail5.jpg" data-full="images/photo5.jpg" alt="5" />
    <img src="images/thumbnail6.jpg" data-full="images/photo6.jpg" alt="6" />
  </div>
  <div class="viewer" id="viewer">
    <img id="imageA" />
    <img id="imageB" />
  </div>
</div>

<script>
  const viewer = document.getElementById('viewer');
  const imgA = document.getElementById('imageA');
  const imgB = document.getElementById('imageB');
  const thumbnails = document.getElementById('thumbnails');
  const thumbnailImgs = thumbnails.querySelectorAll('img');

  let visibleImg = imgA;
  let hiddenImg = imgB;

  let scale = 1;
  let baseScale = 1;
  let translateX = 0;
  let translateY = 0;
  let isZoomed = false;

  let isDragging = false;
  let dragStart = { x: 0, y: 0 };
  let lastTranslate = { x: 0, y: 0 };

  function clampTranslation(img, s, tx, ty) {
    const rect = viewer.getBoundingClientRect();
    const iw = img.naturalWidth * s;
    const ih = img.naturalHeight * s;
    const maxX = Math.max(0, (iw - rect.width) / 2);
    const maxY = Math.max(0, (ih - rect.height) / 2);
    return {
      x: Math.min(maxX, Math.max(-maxX, tx)),
      y: Math.min(maxY, Math.max(-maxY, ty)),
    };
  }

  function applyTransform(img, s, tx, ty) {
    img.style.transform = `translate(calc(-50% + ${tx}px), calc(-50% + ${ty}px)) scale(${s})`;
  }

  function fitImage(img) {
    const rect = viewer.getBoundingClientRect();
    if (!img.naturalWidth || !img.naturalHeight) return;

    const scaleX = rect.width / img.naturalWidth;
    const scaleY = rect.height / img.naturalHeight;

    baseScale = Math.min(scaleX, scaleY);
    scale = baseScale;
    translateX = 0;
    translateY = 0;
    applyTransform(img, scale, translateX, translateY);
  }

  function setImage(src) {
    hiddenImg.style.opacity = 0;
    hiddenImg.src = src;

    hiddenImg.onload = () => {
      fitImage(hiddenImg);

      visibleImg.classList.remove('visible');
      hiddenImg.classList.add('visible');

      scale = baseScale;
      translateX = 0;
      translateY = 0;
      isZoomed = false;
      viewer.classList.remove('zoomed');

      [visibleImg, hiddenImg] = [hiddenImg, visibleImg];
    };
    hiddenImg.onerror = () => {
      console.error('Failed to load image:', src);
    };
  }

  thumbnailImgs.forEach((thumb) => {
    thumb.addEventListener('click', () => {
      const fullSrc = thumb.dataset.full;
      setImage(fullSrc);
    });
  });

  viewer.addEventListener('click', (e) => {
    if (isDragging) return;

    const rect = viewer.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;

    const img = visibleImg;
    if (!img.naturalWidth) return;

    if (!isZoomed) {
      isZoomed = true;
      viewer.classList.add('zoomed');

      const clickRelX = clickX - rect.width / 2 - translateX;
      const clickRelY = clickY - rect.height / 2 - translateY;

      const zoomFactor = 2;
      scale = baseScale * zoomFactor;

      translateX = translateX - clickRelX * (zoomFactor - 1);
      translateY = translateY - clickRelY * (zoomFactor - 1);

      const clamped = clampTranslation(img, scale, translateX, translateY);
      translateX = clamped.x;
      translateY = clamped.y;
    } else {
      isZoomed = false;
      viewer.classList.remove('zoomed');
      scale = baseScale;
      translateX = 0;
      translateY = 0;
    }

    applyTransform(img, scale, translateX, translateY);
  });

  viewer.addEventListener('mousedown', (e) => {
    if (!isZoomed) return;
    isDragging = true;
    dragStart.x = e.clientX;
    dragStart.y = e.clientY;
    lastTranslate.x = translateX;
    lastTranslate.y = translateY;
    viewer.style.cursor = 'grabbing';
    e.preventDefault();
  });

  window.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    const dx = e.clientX - dragStart.x;
    const dy = e.clientY - dragStart.y;

    translateX = lastTranslate.x + dx;
    translateY = lastTranslate.y + dy;

    const clamped = clampTranslation(visibleImg, scale, translateX, translateY);
    translateX = clamped.x;
    translateY = clamped.y;

    applyTransform(visibleImg, scale, translateX, translateY);
  });

  window.addEventListener('mouseup', () => {
    if (isDragging) {
      isDragging = false;
      viewer.style.cursor = 'grab';
    }
  });

  viewer.addEventListener('wheel', (e) => {
    e.preventDefault();
    if (!visibleImg.naturalWidth) return;

    const rect = viewer.getBoundingClientRect();
    const cursorX = e.clientX - rect.left;
    const cursorY = e.clientY - rect.top;

    const zoomStep = 0.1;
    let newScale = scale - (e.deltaY > 0 ? zoomStep : -zoomStep) * scale;
    const minScale = baseScale * 1.6;
    const maxScale = baseScale * 10;

    newScale = Math.min(Math.max(newScale, minScale), maxScale);
    if (newScale === scale) return;

    if (!isZoomed) {
      isZoomed = true;
      viewer.classList.add('zoomed');
    }

    const offsetX = rect.width / 2 + translateX;
    const offsetY = rect.height / 2 + translateY;

    const imgCoordX = (cursorX - offsetX) / scale;
    const imgCoordY = (cursorY - offsetY) / scale;

    scale = newScale;
    translateX = cursorX - imgCoordX * scale - rect.width / 2;
    translateY = cursorY - imgCoordY * scale - rect.height / 2;

    const clamped = clampTranslation(visibleImg, scale, translateX, translateY);
    translateX = clamped.x;
    translateY = clamped.y;

    applyTransform(visibleImg, scale, translateX, translateY);
  });

  window.addEventListener('resize', () => {
    fitImage(visibleImg);
    scale = baseScale;
    translateX = 0;
    translateY = 0;
    isZoomed = false;
    viewer.classList.remove('zoomed');
    applyTransform(visibleImg, scale, translateX, translateY);
  });
</script>
</body>
</html>
