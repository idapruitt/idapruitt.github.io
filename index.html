viewer.addEventListener('pointermove', e => {
  for (let i = 0; i < pointers.length; i++) {
    if (pointers[i].pointerId === e.pointerId) {
      pointers[i] = e;
      break;
    }
  }

  if (pointers.length === 2) {
    const [p1, p2] = pointers;
    const dx = p1.clientX - p2.clientX;
    const dy = p1.clientY - p2.clientY;
    const distance = Math.sqrt(dx * dx + dy * dy);

    const midX = (p1.clientX + p2.clientX) / 2;
    const midY = (p1.clientY + p2.clientY) / 2;

    if (initialPinchDistance === null) {
      initialPinchDistance = distance;
      initialScale = scale;

      // Save current offset of mid point relative to image
      const rect = viewer.getBoundingClientRect();
      const imgX = (midX - rect.left - translateX) / scale;
      const imgY = (midY - rect.top - translateY) / scale;
      viewer.dataset.anchorX = imgX;
      viewer.dataset.anchorY = imgY;
    } else {
      let scaleFactor = distance / initialPinchDistance;
      let newScale = initialScale * scaleFactor;

      newScale = Math.max(baseScale * minScaleFactor, Math.min(newScale, baseScale * maxScaleFactor));
      const prevScale = scale;
      scale = newScale;

      isZoomed = true;
      viewer.classList.add('zoomed');
      thumbnails.classList.add('hidden');

      // Adjust translate so the anchor point stays under fingers
      const anchorX = parseFloat(viewer.dataset.anchorX);
      const anchorY = parseFloat(viewer.dataset.anchorY);

      const rect = viewer.getBoundingClientRect();
      const newX = anchorX * scale;
      const newY = anchorY * scale;
      const oldX = anchorX * prevScale;
      const oldY = anchorY * prevScale;

      translateX -= (newX - oldX);
      translateY -= (newY - oldY);

      applyTransform();
    }
  } else if (isDragging && isZoomed) {
    hasDragged = true;
    const dx = e.clientX - dragStart.x;
    const dy = e.clientY - dragStart.y;
    translateX = lastTranslate.x + dx;
    translateY = lastTranslate.y + dy;
    applyTransform();
  }
});
